* Migration Goals and Priorities

All OHC API calls will be handled by Erlang-based web services that
store their data in PostgreSQL. We will deploy OHC in a configuration
that looks as much like OPC as possible. Acheiving these goals will
require multiple migrations. The priority list below will help us
shape the migrations to best meet business needs.

1. Performance and efficiency. Significantly reduce 95-percentile
   latency of API requests. Reduce RAM and CPU across both front and
   back end servers.
2. Tighter correspondence between OHC and OPC.
3. Remove couchdb from our infrastructure

** secondary goals
1. OPC migration tooling
2. OSC migration tooling

** Questions for all migrations
*** Do we want to use a different proxy/FE (not nginx) to make migration easier
*** Can we move the data in a downtime window
*** How much value is there in being able to guinea pig some orgs in new world
*** What happens if an org's data fails to migrate, or if we are only partially complete at end of window

* Migration 1: Nodes to MySQL (DONE)
* Migration 2: MySQL to PostgreSQL
** Questions
1. Do we need new hardware by way of an additional high-power HA pair?
2. Do we want to consider moving the community site so that
3. Can we do a full dump and load within an acceptable full outage
   window? Do we have other options? Batches of orgs? Users separate
   from nodes? Would a pre-load and UPDATE if modified time not
   matching be faster? Would customers prefer a scenario in which we
   snapshot and "restore" pg from snapshot and swap over so that OHC
   remains maximally available, but some data will be lost?
4. When will reporting be in its own db? Will it go straight into pg?
5. Does reporting data need to be migrated if we migrate before GA of
   reporting?
6. If reporting data needs to migrate, is there read-only data that
   could be moved ahead of time?
7. Should we upgrade to a sane user table schema before, after, or as
   a part of this migration?
** Deploy postgres to preprod
** Deploy HA postgres to prod
*** test HA failover
** Establish postgres data backup
*** research backup options
Looks like zmanda has [[http://www.zmanda.com/postgres-backup.html][an offering]] so that might be easiest since we
are already using it for mysql.
*** implement backup
*** test recovery
** Write dump and load mysql to pg tool
*** Time dump/load time, is it reasonable for a full downtime outage?
** Integrate pg client in oc-account
** Integrate pg client into oc-chef
** Integrate pg client into oc_erchef
** Integrate pg client into oc_reporting
** Community site?
** Convert cron scripts that pull data from mysql for internal reports
** Update support tool
** Update org-mapper
** Migrate
*** full outage
*** dump, load
*** config change and restart services
* Implement 2.1: Finish /clients for oc_erchef OPC/OHC
* Migration 3: Uncle Ned Parity + clients
The following endpoints would move to oc_erchef and pgsql:
- clients
- cookbooks, cookbook versions (and dep solver)
- data bags and data bag items
- environments
- roles
- sandboxes
- checksums
** Build moser migrator tooling for the nine types
** Enhance chef-mover to drive moser migrator
** Measure migration time. Will batches be required?
** Migrate guinea pigs?
** Perform migration
** What will be left in couchdb?
- groups
- containers
- global stuff
  - user/org association
  - user/org invites
  - global admin groups (one per org)
  - global admin group container?
  - orgs container
  - users container
* Implementation 3.5: Global Data in SQL
* Migration 4: Global Data
At least the data for the following endpoints and magic objects would
mobe to pgsql:
- groups
- orgs
- global ORGX_admins_group groups
- global containers (admins group, users, orgs)
- user/org associations
- user/org invites
** Questions
1. Do we want to just move the data or move oc-account funcationality
   to an Erlang-based webservice?
2. Can the entire migration fit in an outage window?
3. Do we have to migrate unassigned orgs? Is there a way to
   pre-create unassigned orgs in the new system?
* Implementation 4.5: groups and containers in SQL
* Migration 5: Remaining chef_05ad data to pgsql
Includes:
- groups
- containers
* Implementation 5.5: New Authz
* Migration 6: authz and the grand de-couch-ification

* Tensions
- Live migration vs downtime
- # of total migrations vs downtime, risk, and fixed costs of each migration
- Ability to recover from failed migrations or function with only some
  orgs having completed migration


* Survey of data to migrate
** Global Data
Except for user data, global data currently lives in the
=opscode_account= couchdb database. All global data is currently
handled by the opscode-account service. The opscode-account service
is still implemented in Merb.

#+CAPTION: Summary of global data in OHC and OPC
| global data          | current service | current location        | size |
|----------------------+-----------------+-------------------------+------|
| users                | oc-account      | SQL                     |      |
| orgs                 | oc-account      | couch "opscode_account" |      |
| global groups        | oc-account      | couch "opscode_account" |      |
| global containers    | oc-account      | couch "opscode_account" |      |
| org invites          | oc-account      | couch "opscode_account" |      |
| user/org association | oc-account      | couch "opscode_account" |      | 
   
** Org-specific
** Org Creation Details
opscode-org-creator uses code in opscode-account (specifically the
bin/bootstraptool script) to pre-create orgs.

*** Flow of org pre-creation via bootstraptool
1. Call create_org_internal making a POST to /internal-organizations
   with full_name, name, and org_type.
2. Make the org "unassigned" via make_org_unassigned. PUT to
   /internal-organizations/ORGNAME with body ={"unassigned":true}=.
*** What happens in processing a POST to /internal-organizations
1. Fetch global organizations container
2. Verify requesting actor has CREATE on organizations container
3. Verify org name does not exist
4. Obtain handle to free billing plan
5. (OHC only) Register org as new customer with Chargify. Obtain
   subscription_id and customer_id.
6. Save org
7. Call =org.setup!=. This code lives in mixlib-authorization in
   organization.rb.
   1. Creates couchdb "chef_" database and initializes it with design
      docs. Creates default environment if environments are in couch.
   2. Uses =OrgAuthPolicy= to apply policy. See below.
*** Details of OrgAuthPolicy
Global groups are groups where the user/chef-side of the group lives
in the opscode-account db rather than in the chef_beef db.

It appears that the only global groups are org-specific global admins
groups. These groups are named as =ORGNAME_global_admins=. They are
created as part of pre-create via auth policy. They are renamed
during org assignment. When a user accepts an association request,
the ORG_global_admins group is added to the READ ace of the
associating user. This allows users in an org to have READ access on
other users in the same org.

Where are global groups accessed?

#+BEGIN_EXAMPLE
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # SECURITY: spoofing requesting actor
    # To disassociate a user with an org requires removing the org's global admins group from the user's read ace
    # To do so, the requesting actor needs to have the GRANT ace on the user
    # The requesting actor is another user who should not have the GRANT ace on the user
    # To disassociate the user, we will spoof the requesting actor id to be the auth id of the user
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#+END_EXAMPLE

#+BEGIN_SRC ruby
require 'mixlib/authorization/org_auth_policy'

#== Default Authz Policy/Settings for Organizations
#
# SEE ALSO: https://wiki.corp.opscode.com/display/CORP/Authorization+Matrix
Mixlib::Authorization::OrgAuthPolicy.default do |org|


  debug("Creating Default Containers")
  org.has_containers( :clients, :groups, :cookbooks, :data, :containers,
                      :nodes, :roles, :sandboxes, :environments)

  debug("Creating Default Groups")
  org.has_groups(:users, :clients, :admins, "billing-admins")

  debug("Creating Global Admins Group")
  org.has_global_admins_group

  debug("Applying Policy for billing admins")
  org.group("billing-admins") do |billing_admins|
    billing_admins.have_rights(:read, :update) do |on|
      on.group("billing-admins")
    end

    billing_admins.clear_groups_from(:create, :delete, :grant)
  end

  debug("Applying Policy for Local Admins Group")
  org.group(:admins) do |admins|

    admins.includes_superuser

    admins.have_rights(:read, :update, :create, :grant, :delete) do |on|
      on.all_containers
      on.groups(:admins, :users, :clients)
      on.organization
    end
  end

  debug("Applying Policy for Users Group")
  org.group(:users) do |users|
    users.includes_superuser

    users.have_rights(:create, :read, :update, :delete) do |on|
      on.containers(:cookbooks, :data, :nodes, :roles, :environments)
    end

    users.have_rights(:read, :delete) do |on|
      on.containers(:clients)
    end

    users.have_rights(:read) do |on|
      on.containers(:groups, :containers)
      on.organization
    end

    users.have_rights(:create) do |on|
      on.containers(:sandboxes)
    end
  end

  debug("Setting Policy for Clients Group")
  org.group(:clients) do |clients|
    clients.have_rights(:read, :create) do |on|
      on.containers(:nodes)
    end

    clients.have_rights(:create, :read, :update, :delete) do |on|
      on.containers(:data)
    end

    clients.have_rights(:read) do |on|
      on.containers(:cookbooks, :environments, :roles)
    end
  end

  debug("Creating default objects")
  create_default_objects do
    # Create the Mixlib::Authorization document for the _default environment
    Mixlib::Authorization::Models::Environment.on(org_db).new(:name=>"_default", :requester_id => requesting_actor_id, :orgname=>org_name).save
  end
end
#+END_SRC




* Research
** Inventory chef_* objects
** Inventory opscode_account objects
** Disable/sunset quick starts
** Sweep deployed software for usage of each type
*** opscode-account
*** opscode-chef
*** chef
*** opscode-org-creator
*** opscode-certificate
*** orgmapper
*** oc_reporting
*** oc_erchef
*** community site
*** opscode-webui
*** utilities
** Understand groups and containers global vs local

* Misc notes
** groups
*** Do we use this as an excuse to drive USAG / SOSA's forward
** org creation and policy application
*** does this use API or is it hooked into low level ruby/db objects
*** can we just port existing to SQL?

** chargify
*** What's its couch usage?
*** How complicated is the REST API?

** GLOBALS: what's in global
*** users (already in SQL)
*** some groups
*** some containers
*** orgs
*** invites
*** org association

** opscode_account: how separate is it?

* Notes opscode_account schema reverse engineering
** views:
*** AssociationRequest
**** Name:  _design/AssociationRequest-bf34293bc3d23b3db03146881171493d
**** Size: about 166 docs in preprod
**** Doc Schema
     couchrest-type: AssociationRequest
     organization: org GUID
     user: user GUID of some sort
     organization_admin_actor_id:
**** Users: TODO
*** Mixlib::Authorization::AuthJoin
**** Name: _design/Mixlib::Authorization::AuthJoin (Inactive view)
**** Name: _design/Mixlib::Authorization::AuthJoin-25834c5a8d6a9586adb05320f3f725e8
**** Size: about 1.16 M docs in preprod
**** Doc Schema
     couchrest-type: Mixlib::Authorization::AuthJoin
     auth_object_id: auth side object GUID
     user_object_id: user side object GUID
**** Users: TODO

*** Mixlib::Authorization::Models::Client
**** Name: _design/Mixlib::Authorization::Models::Client-fec21b157b76e08b86e92ef7cbc2be81
**** NOTE: may be unused! Has all this gone to SQL?
**** Size: NO DOCS in preprod
     
*** Mixlib::Authorization::Models::Container
**** Name: _design/Mixlib::Authorization::Models::Container (Inactive view)
**** Name:  _design/Mixlib::Authorization::Models::Container-f6aead5acfa18f649f9f951ad5570324
**** Size: 2 docs (see below)
**** Doc Schema
     couchrest-type: Mixlib::Authorization::Models::Client
     containername: name
     containerpath: name
     requester_id: (GUID)
**** Note
     only two docs exist:
     organizations (name/path same)
     users (name/path same)
*** Mixlib::Authorization::Models::Group
**** Name: _design/Mixlib::Authorization::Models::Group-59a505c964199e318b67910cc642a062
**** Size: 18K docs in preprod (not as many as there are orgs; possibly not there for precreated orgs?) 
**** Doc Schema
     couchrest-type: Mixlib::Authorization::Models::Group
     actor_and_group_names: groups: [list of members]
     groupname: ORGNAME_global_admins (where ORGNAME is the actual name, e.g. 001_global_admins
     orgname: actual name of org (e.g. 001)
     requester_id: GUID of requestor (generally pivotal 4920224947d7ed92e872e53b620e94b7)
     
     It looks like these are created for unassigned orgs (aadfpwkihcdefoyodgbn_global_admins)

*** Mixlib::Authorization::Models::Organization
**** _design/Mixlib::Authorization::Models::Organization (inactive)
**** _design/Mixlib::Authorization::Models::Organization-2d2195f97596850adcab2fe4a47e4ab9 (inactive)
**** _design/Mixlib::Authorization::Models::Organization-eed4ffc4a127815b935ff840706c19de 
**** Size: 25K docs
**** Doc Schema 
     couchrest-type: Mixlib::Authorization::Models::Organization
     assigned_at: date
     billing_plan: platform-free
     chargify_customer_id: 1300443
     chargify_subscription_id: 1308808
     clientname: az-validator
     full_name: human readable name
     guid: 30db482adc8f48399387a0417d52a5bf
     name: short name ("Pre-created" for pre-created orgs)
     org_type: Only type I've found so far is 'Business'
     requester_id: A guid (948465a564a458797b26c3442d6a18e9)

*** Mixlib::Authorization::Models::User
**** _design/Mixlib::Authorization::Models::User (seems to be active)
**** _design/Mixlib::Authorization::Models::User-1362073e995844cc72a5d40fba783cb9 (inactive)
**** _design/Mixlib::Authorization::Models::User-29b9399f9c8ef75095bf05bcab454f2c (inactive)
**** _design/Mixlib::Authorization::Models::User-d91081011f53ef032d42ce42f76fc9ed (inactive)
**** _design/Mixlib::Authorization::Models::User-e8e718b2cc7860fc5d5beb40adc8511a (inactive)
**** Size: 8.6K docs
**** Question: is this just residual from before the sql migration of users...
**** Doc Schema:
     _id: is guid of user...
     couchrest-type: Mixlib::Authorization::Models::User
     certificate: RSA CERT
     city: 
     country:
     display_name: 
     email: 
     first_name: 
     image_file_name:
     last_name:
     middle_name:
     password:
     salt:
     twitter_account
     username

*** OrganizationUser
**** _design/OrganizationUser (inactive)
**** _design/OrganizationUser-59f856e73fb179067256ec5ac7ebdff6 (inactive)
**** _design/OrganizationUser-5c1085b0dd852acf9c74bbfe97f66406 (active)
**** Size: 20K docs
**** Doc Schema:    
     couchrest-type: OrganizationUser
     organization: GUID of org
     user: GUID of user
