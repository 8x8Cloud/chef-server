#!/usr/bin/env bash
#
# Authors:: Chef Support Team <support-team@getchef.com>
#

[ -r /etc/opscode/private-chef.sh ] && source /etc/opscode/private-chef.sh
POSTGRESQL_UNIX_USER=${POSTGRESQL_UNIX_USER:=opscode-pgsql}

modified_within_last_x_minutes=180
tail_lines=10000

type='CS'
if [[ -n $1 ]];
then
    type=$1
fi

if [[ $type == 'CS' ]];
then
    path='opscode'
    ctl_cmd='private-chef-ctl'
    config_name='*chef*.rb'
    ha=$(egrep -qs 'topology[[:space:]]+.*ha' /etc/opscode/*chef*.rb)$?

    if [[ ! -e "/opt/$path/bin/$ctl_cmd" ]];
    then
	echo "ERROR: Enterprise or Chef server may not be installed."
	exit 1
    fi

    echo "Gathering logs from Enterprise or Chef server."
elif [[ $type == 'OSC' ]];
then
    path='chef-server'
    ctl_cmd='/opt/chef-server/bin/chef-server-ctl'
    config_name='chef-server.rb'

    if [[ ! -e "/opt/$path/bin/$ctl_cmd" ]];
    then
	echo "ERROR: Open Source Chef server may not be installed."
	exit 1
    fi

    echo "Gathering logs from Open Source Chef server."
elif [[ $type == 'Analytics' ]];
then
    path='opscode-analytics'
    ctl_cmd='opscode-analytics-ctl'
    config_name='opscode-analytics.rb'

    if [[ ! -e "/opt/$path/bin/$ctl_cmd" ]];
    then
       echo "ERROR: Analytics server may not be installed."
       exit 1
    fi

    echo "Gathering logs from Analytics server."
else
    echo "Usage: gather-logs [ CS | OSC | Analytics ]"
    echo "CS - Enterprise or Chef server (default)"
    echo "OSC - Open Source Chef server"
    echo "Analytics - Opscode Analytics server"
    exit 1
fi

hostname=$(hostname)
timestamp=$(date +%F_%H.%M.%S-%Z)
tmpdir="$(mktemp -d)/$hostname/$timestamp"
#RHEL5 has ip and other tools here
PATH=$PATH:/bin:/sbin

mkdir -p "$tmpdir"

for i in /opt/{chef,$path}*/version-manifest.txt \
    /opt/$path/pc-version.txt \
    /etc/$path/$config_name \
    /etc/${path}*/*-running.json \
    /var/log/syslog \
    /var/log/messages; do
    if [[ -e "$i" ]]; then
	mkdir -p "$tmpdir/`dirname ${i:1}`"
	tail -"$tail_lines" "$i" > "$tmpdir/${i:1}"
    fi
done

for i in `find /var/log/${path}* -type f -mmin -"$modified_within_last_x_minutes"`; do
    if [[ -e "$i" ]]; then
	mkdir -p "$tmpdir/`dirname ${i:1}`"
	tail -"$tail_lines" "$i" > "$tmpdir/${i:1}"
    fi
done

$ctl_cmd status > "$tmpdir/$ctl_cmd"_status.txt

if [[ ($type == 'CS') && ($ha == 0) ]]; then
    for i in /var/log/$path/keepalived/cluster.log /proc/drbd; do
	if [[ -e "$i" ]]; then
	    mkdir -p "$tmpdir/`dirname ${i:1}`"
	    tail -"$tail_lines" "$i" > "$tmpdir/${i:1}"
	fi
    done

    $ctl_cmd ha-status > "$tmpdir/$ctl_cmd"_ha-status.txt
fi

# Try to determine with /tmp/.s.PGSQL.5432 if postgresql is running before gathering psql logs
# There are two cases in which this could fail:
# 1) We've configure postgresql to listen on a different local socket. Most users don't do this, but it is possible.
# 2) Postgresql isn't running.
# Since the general goal of this script is to collect whatever we can for support but not present confusing errors to 
# the user, we went for a test that covered (2) easily. If we can do something smart that would account for (1) that 
# would be cool, but my sense is that this is OK for now.

if [[ -S "/tmp/.s.PGSQL.5432" ]]; then
    if [[ $type == 'CS' ]];
    then
	echo "SELECT CURRENT_TIMESTAMP; SELECT * FROM pg_stat_activity;" | su -l $POSTGRESQL_UNIX_USER -c 'psql opscode_chef' > "$tmpdir/pg_stat_activity.txt"

	echo "SELECT * FROM sqitch.tags;" | su -l $POSTGRESQL_UNIX_USER -c 'psql opscode_chef' > "$tmpdir/opscode_chef_sqitch_tags.txt"
	echo "SELECT * FROM sqitch.tags;" | su -l $POSTGRESQL_UNIX_USER -c 'psql bifrost' > "$tmpdir/bifrost_sqitch_tags.txt"

	su -m $POSTGRESQL_UNIX_USER -c 'ulimit -a' > "$tmpdir/ulimit_a_opscode-pgsql.txt"
    fi
   if [[ $type == 'Analytics' ]];
   then
      echo "SELECT CURRENT_TIMESTAMP; SELECT * FROM pg_stat_activity;" | su -l chef-pgsql -c 'psql actions' > "$tmpdir/pg_stat_activity.txt"

      echo "SELECT * FROM schema_migrations;" | su -l chef-pgsql -c 'psql actions' > "$tmpdir/actions_schema_migrations.txt"

      su -m chef-pgsql -c 'ulimit -a'> "$tmpdir/ulimit_a_chef-pgsql.txt"
   fi
fi

# Retrieve Platform and Platform Version
if [[ -f "/etc/lsb-release" ]] && grep -q DISTRIB_ID /etc/lsb-release;
then
    cp "/etc/lsb-release" "$tmpdir/platform_version.txt"
elif [[ -f "/etc/redhat-release" ]];
then
    cp "/etc/redhat-release" "$tmpdir/platform_version.txt"
else
    echo "Platform and version are unknown." > "$tmpdir/platform_version.txt"
fi

uptime > "$tmpdir/uptime.txt"

cp "/proc/cpuinfo" "$tmpdir/cpuinfo.txt"

cp "/proc/meminfo" "$tmpdir/meminfo.txt"

free -m > "$tmpdir/free-m.txt"

ps fauxww > "$tmpdir/ps_fauxww.txt"

df -h >  "$tmpdir/df_h.txt"

df -i >  "$tmpdir/df_i.txt"

if [[ -e /opt/opscode-manage/bin/opscode-manage-ctl ]];
then
   /opt/opscode-manage/bin/opscode-manage-ctl status > "$tmpdir/opscode-manage-ctl_status.txt"
fi

if [[ -e /opt/opscode-reporting/bin/opscode-reporting-ctl ]];
then
   /opt/opscode-reporting/bin/opscode-reporting-ctl status > "$tmpdir/opscode-reporting-ctl_status.txt"
fi

su -m opscode -c 'ulimit -a' > "$tmpdir/ulimit_a_opscode.txt"

ip addr show > "$tmpdir/ip_addr_show.txt"

# ss(8) is the command for socket statistics that replaces netstat
#RHEL5 only has netstat
if which ss > /dev/null 2>&1
then
  ss -ontap > "$tmpdir/ss_ontap.txt"
else
  netstat -alntp > "$tmpdir/netstat_alntp.txt"
fi

sysctl -a > "$tmpdir/sysctl_a.txt" 2>&1

dmesg > "$tmpdir/dmesg.txt"

function add_footer (){
  echo "---" >> "$1"
  echo ""    >> "$1"
}

name_resolution_file="$tmpdir/name-resolution.txt"

if which dig > /dev/null 2>&1; then
    echo '## dig hostname -f' > "$name_resolution_file"
    dig `hostname -f` >> "$name_resolution_file"
fi
add_footer "$name_resolution_file"

echo '## /etc/resolv.conf' >> "$name_resolution_file"
cat /etc/resolv.conf >> "$name_resolution_file"
add_footer "$name_resolution_file"

echo '## ping hostname' >> "$name_resolution_file"
ping -c 2 `hostname` >> "$name_resolution_file"
add_footer "$name_resolution_file"

echo '## ping hostname -f' >> "$name_resolution_file"
ping -c 2 `hostname -f` >> "$name_resolution_file"
add_footer "$name_resolution_file"

echo '## /etc/hosts' >> "$name_resolution_file"
cat /etc/hosts >> "$name_resolution_file"
add_footer "$name_resolution_file"

if [[ $type == 'CS' ]];
then
    fqdn="api_fqdn"
    config_file_path="/etc/opscode/chef-server.rb"
elif [[ $type == 'Analytics' ]];
then
    fqdn="analytics_fqdn"
    config_file_path="/etc/opscode-analytics/opscode-analytics.rb"
fi
tempname=`grep -E $fqdn $config_file_path | cut -d \" -f2`

#Didnt find a hostname above, so fallback
if [[ -z $tempname ]];
then
    tempname=$hostname
fi

echo '## Resolved Name + Time' >> "$name_resolution_file"
echo $tempname >> "$name_resolution_file"
for interval in `seq 1 5`; do
    { time /opt/$path/embedded/bin/ruby -e "require 'resolv'; start=Time.now; p Resolv.getaddress(\"$tempname\")" ; } >> "$name_resolution_file" 2>&1
    sleep 2;
done

for fileperms in \
    /var/opt/$path* \
    /var/log/$path*; do
    ls -altuhR "$fileperms" >> "$tmpdir/perms.txt"
done

tar -C "${tmpdir%/*/*}" -cjpf "$hostname-$timestamp.tbz2" "$hostname/$timestamp/"

rm -rf "${tmpdir%/*/*}"

echo "Logs gathered in $hostname-$timestamp.tbz2"
