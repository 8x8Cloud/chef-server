This is the Erlang implementation of Chef's REST API.

Currently implemented endpoints are:

* Search: /organizations/<org_id>/search/<obj_type>

Note: Parameters are enclosed in angle brackets

Building erchef (tl;dr version)
---------------------------------
1) Install Erlang R14B03 or later

2) Run 'make rel'

3) 'cd rel/erchef;bin/erchef start'

4) Profit!

Building erchef (longer version)
----------------------------------
1) Install Erlang R14B03 or later

2) (Optional) Build dialyzer PLT which includes erts, kernel, stdlib, crypto,
   and public_key. If you've never done this before, use the command below:

   dialyzer --build_plt --apps erts kernel stdlib crypto public_key

3) Run 'make'. This will download all dependencies and compile all code.

4) Run 'make test'. This will execute the test suites for chef_rest and
   chef_common. All tests should pass.

5) (Optional) If you've got an up to date PLT file (see #2) you can use
   dialyzer to perform static analysis on erchef. Running 'make dialyzer'
   will perform analysis against chef_rest and chef_common.

6) erchef is designed to be deployed as a standalone OTP release. You can
   build a release via either 'make rel' or 'make devrel'. The devrel target
   is highly recommended for developers working on erchef directly. This
   target symlinks all dependencies and application so the release doesn't
   have to be rebuilt each time code is changed.

   If a release has been built via 'make devrel' you can rebuild and load
   changed code into the running erchef instance via 'make update'.
   NOTE: This performs a warm reboot of the Erlang VM so any application
   state will be totally lost.

7) You can start the erchef release with an interactive shell via the
   command below:

   cd rel/erchef;bin/erchef console

Deploying to rs-preprod
-----------------------

    knife ec2 server create -G rs-preprod,platform-server \
        --flavor m1.small -I ami-9a9c6bf3 \
        -x ubuntu -r 'role[opscode-erchef],role[rs-preprod]' \
        -i ~/.ssh/opscode-preprod-20101208

Search Error Cases
------------------

- [X] missing signature
- [X] q param defaults to "*:*"
- [X] request time out of bounds
- [X] bad signature
- [X] not in org
- [X] no such org
- [X} no such user/client.  these are the same from the search resource level.
- [X] bad query (can't parse)
- [X] invalid extra params (rows=foo, rows=-10)
- [X] params: start, rows, sort, q.  Do we actually support sort?
  - default values for start, rows, sort
- [X] verify that user can't manipulate filter to escape org guid filter
- bad type (not a node, role, client, or environment). Do we need to
  validate data bag?

Data Bag Queries
----------------

Ruby code goes to couchdb prior to each request to verify the list of
known data bags.  If data bag is not found, returns 404, otherwise
continues with search.  We need to either repro that call or do the
following which should save on calls to couch for the common case.

1. Execute data bag search.  If we get results, go to #2, otherwise #3

2. (solr returned IDs) Fetch objects from couch using IDs from solr.
   If no results, go to #3, otherwise #4.

3. (no objects found for IDs, or no IDs from solr) Fetch list of data
   bags from couch.  If searched for data bag exists, return empty
   result set 200, otherwise return 404.

4. Return result set 200.

So we need:

- [ ] chef_otto:data_bag_exists(S, Db, BagName) -> boolean()
- [ ] implement logic as above.

Stuff
-----

Request signing ignores query parameters (!)

